<html>
<head>
</head>
<body>
<script src="http://code.jquery.com/jquery-1.10.1.min.js"></script>
<script type="text/JavaScript" src="jsDraw2D.js"></script>
<script type="text/JavaScript" src="PLA.js"></script>
<div id="control">
  <div>
    <label for="N">N = </label>
    <input type="text" name="N" id="N" value="100" />
  <button id="train">Train until all N correct</button>
  </div>
  <div>
    <button id="step">Train one misclassified point</button>
  </div>
  <div>
    <button id="reset">Reset</button>
  </div>
</div>
<div id="canvas" style="position:relative;width:500px;height:500px;" />
<script type="text/JavaScript">

  window.red = new jsColor("red");
  window.redPen = new jsPen(red,1);
  window.blue = new jsColor("blue");
  window.bluePen = new jsPen(blue,1);
  window.black = new jsColor("black");
  window.blackPen = new jsPen(black,1);
  window.green = new jsColor("green");
  window.greenPen = new jsPen(green,4);

  window.smallFont = new jsFont("sans-serif", "normal", "x-small");

  window.initCanvas = function() {
    if(window.gr && window.gr.clear) window.gr.clear();
    window.gr = new jsGraphics(document.getElementById("canvas"));
    window.gr.setOrigin(new jsPoint(250,250));
    window.gr.setScale(200);
    window.gr.setCoordinateSystem("cartecian"); 
    window.gr.showGrid(1);
  }

  window.plotLine = function(points, pen) {
    window.gr.drawLine(pen ? pen : blackPen,
    new jsPoint(points[0][0],points[0][1]),
    new jsPoint(points[1][0],points[1][1])); 
  }
  window.plotPoint = function(point, color) {
    window.gr.fillCircle(color,new jsPoint(point[0],point[1]),0.01);
  }
  window.plotCircle = function(point, pen) {
    window.gr.drawCircle(pen, new jsPoint(point[0],point[1]), 0.02);
  }
</script>

<script type="text/JavaScript">
  window.untilFit = function(NumberOfN) {
    var plane = new window.TestPlane(-1,1,-1,1);
    var N = [];
    var pla = new window.PLA([0,0,0], function(x) {return Math.sign(x);});
    var numberOfErrorTestPoint = 100000;
    var errorPointCount = 0;

    window.initCanvas();
    window.plotLine(plane._line);

    for(var i = 0; i < NumberOfN; i++) {
      N.push(plane.randomPoint());
    }

    var incorrectPoints = [];
    do {
      incorrectPoints = [];
      for(var i in N) {
        if(plane.getOutput(N[i]) !== pla.getOutput(N[i])) {
          incorrectPoints.push(N[i]);
        }
      }

      if(incorrectPoints.length !== 0) {
        var incorrectPoint = incorrectPoints[Math.floor(Math.random() * incorrectPoints.length)];
        pla.train(incorrectPoint, plane.getOutput(incorrectPoint))
      }
    } while(incorrectPoints.length !== 0)

    for(var k = 0; k < N.length; k++) {
      var sign = pla.getOutput(N[k]);
      window.plotPoint(N[k], (sign < 0 ? red : blue));
    }

    var trainedLine = window.weightsToLine(pla._weights ,plane);
    window.plotLine(trainedLine, redPen);

    for(var l = 0; l < numberOfErrorTestPoint; l++) {
      var randomPoint = plane.randomPoint();
      if(plane.getOutput(randomPoint) !== pla.getOutput(randomPoint)) errorPointCount += 1;
    }

    var weightsRounded = [];
    for(var m in pla._weights) {
      weightsRounded.push(pla._weights[m].toFixed(4));
    }

    var label = 'Weights: ' + weightsRounded.join(', ') + '<br />'
              + 'Iteration: ' + pla._iteration + '<br />'
              + 'Error rate: ' + errorPointCount/numberOfErrorTestPoint;

    window.gr.drawText(label, new jsPoint(-1, 1.24), smallFont, black, 1, 'center');

    return {weights: pla._weights, iteration: pla._iteration, errorRate: errorPointCount/numberOfErrorTestPoint};
  }

  window.trainOnce = function(NumberOfN) {
    if(!window.currentPLA) window.currentPLA = new window.PLA([0,0,0], function(x) {return Math.sign(x);});
    if(!window.currentPlane) window.currentPlane = new window.TestPlane(-1,1,-1,1);
    if(!window.currentN) {
      window.currentN = [];
      for(var i = 0; i < NumberOfN; i++) {
        window.currentN.push(window.currentPlane.randomPoint());
      }
    }
    if(!window.trainedPoint) window.trainedPoint = [];

    // Stop if all points are correct
    var incorrectPoints = [];
    for(var i in currentN) {
      if(currentPlane.getOutput(currentN[i]) !== currentPLA.getOutput(currentN[i])) {
        incorrectPoints.push(currentN[i]);
      }
    }
    if(incorrectPoints.length === 0) return;
    console.log(incorrectPoints.length);

    var weightsBefore = $.extend([],currentPLA._weights);

    var incorrectPoint = incorrectPoints[Math.floor(Math.random() * incorrectPoints.length)];
    var expectedOutput = currentPlane.getOutput(incorrectPoint);
    console.log(currentPLA.train(incorrectPoint, expectedOutput));

    var numberOfErrorTestPoint = 100000;
    var errorPointCount = 0;
    for(var m = 0; m < numberOfErrorTestPoint; m++) {
      var testErrorPoint = currentPlane.randomPoint();
      if(currentPlane.getOutput(testErrorPoint) !== currentPLA.getOutput(testErrorPoint)) errorPointCount += 1;
    }

    // Redraw
    window.initCanvas();
    window.plotLine(currentPlane._line);

    var trainedLine = window.weightsToLine(currentPLA._weights ,currentPlane);
    window.plotLine(trainedLine, redPen);

    for(var k = 0; k < currentN.length; k++) {
      var sign = currentPLA.getOutput(currentN[k]);
      window.plotPoint(currentN[k], (sign < 0 ? red : blue));
    }

    window.plotCircle(incorrectPoint, greenPen);

    var weightsBeforeRounded = [];
    for(var j in weightsBefore) {
      weightsBeforeRounded.push(weightsBefore[j].toFixed(4));
    }

    var weightsRounded = [];
    for(var k in currentPLA._weights) {
      weightsRounded.push(currentPLA._weights[k].toFixed(4));
    }

    var incorrectPointRounded = [];
    for(var l in incorrectPoint) {
      incorrectPointRounded.push(incorrectPoint[l].toFixed(4));
    }

    var label1 = 'Weights before: ' + weightsBeforeRounded.join(', ') + '<br />'
              + 'Weights after: ' + weightsRounded.join(', ') + '<br />'
              + 'Train point: ' + incorrectPointRounded.join(', ');

    var label2 = 'Iteration: ' + currentPLA._iteration + '<br />'
               + 'Error rate: ' + errorPointCount/numberOfErrorTestPoint;

    window.gr.drawText(label1, new jsPoint(-1, 1.24), smallFont, black, 1, 'center');
    window.gr.drawText(label2, new jsPoint(0, 1.24), smallFont, black, 1, 'center');
  }

  window.weightsToLine = function(weights, plane) {
    var y_on_x_min = -1 * (weights[1] * plane._x_min + weights[0]) / weights[2];
    var y_on_x_max = -1 * (weights[1] * plane._x_max + weights[0]) / weights[2];
    var x_on_y_min = -1 * (weights[2] * plane._y_min + weights[0]) / weights[1];
    var x_on_y_max = -1 * (weights[2] * plane._y_max + weights[0]) / weights[1];

    var result = [];

    if(y_on_x_min >= plane._y_min && y_on_x_min <= plane._y_max) {
      result.push([plane._x_min, y_on_x_min]);
    }
    if(y_on_x_max >= plane._y_min && y_on_x_max <= plane._y_max) {
      result.push([plane._x_max, y_on_x_max]);
    }
    if(x_on_y_min >= plane._x_min && x_on_y_min <= plane._x_max) {
      result.push([x_on_y_min, plane._y_min]);
    }
    if(x_on_y_max >= plane._x_min && x_on_y_max <= plane._x_max) {
      result.push([x_on_y_max, plane._y_max]);
    }
  if(result.length !== 2) result = [[0,0,],[0,0]];
  return result;
  }

  window.reset = function() {
    window.currentPLA = null;
    window.currentPlane = null;
    window.trainedPoint = null;
    window.currentN = null;
    window.initCanvas();
  }

  window.initCanvas();
  $('#train').on('click', function() { window.untilFit($('#N').val()); });
  $('#step').on('click', function() { window.trainOnce($('#N').val()); });
  $('#reset').on('click', function() { window.reset(); });
</script>
</body>
</html>